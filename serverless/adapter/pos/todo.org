* Porting adapter to AWS
   - write each handler as separate function
   - generate serverless.yml file with separate function entries
   - deploy each handler as separate function
   - deploy message reception handler
   - configure adapter w/ json spec for handlers
     - map message names to function ARNs
     - maybe use CF to query based on names
     - maybe use decorators on function defs to register
       don't call functions directly, but via lambda.invoke
   - process incoming messages
     receive(event, context):
       insert message
       invoke handler for message

** Dynamo Table Design
   - Partition key
     The first key in the protocol?
   - Sort key - make all items (messages) unique
     - Timestamp?
     - Hash?

** Enactments
   For enactments, we need to select by the key, and filter to match all of the remaining enactment or message keys.
   The remaining items are all those that are part of the same enactment.

   Handlers should be called with the enactment query results

** Correctness Checks
*** 'In' Dependencies
    Ins just need to exist in any message, not necessarily the same enactment.
    Thus, this check needs to be a scan query.
    It should scan the whole database for any message that match that 'in' parameter.

*** Integrity, Out and Nil
    These checks depend on a specific enactment, and can use a key + filter query to narrow the results down to only the relevant messages.
    Then use for loops across the enactment to check each of the constraints.
